###Script to analyze Zostera marina pooled data (23 populations) using poolfstat and BayPass R functions
#Much of this script is based off a tutorial by Erica Nielsen at https://esnielsen.github.io/post/pool-seq-analyses-poolfstat-baypass/ 
library(poolfstat)
library(WriteXLS)
library(corrplot)
library(ape)
library(vegan)
library(ggbiplot)

#Set our directory to where the trimmed and realigned bam, pileup, and sync files are
setwd("/hdd2/Snow_Crab_PoolSeq/Trimmed/")
#Load the Rdata
load("SnowCrabPoolfstat.RData")

#Make some plots using the fst data from Popoolation2
library("qqman")
library("DataCombine")



fst = read.table("AllPools_w1000.fst", header = F) 
colnames(fst) <-c("CHR", "BP", "SNPs","FRACTION","COV",paste0("V",6:258)) #rename column headers
fst$ID <- paste(fst$CHR,fst$BP,sep=".")

fst2<-fst
fst<-fst2
#tidying file
fst$CHR<-gsub(pattern = "Chr", replacement = "",x = fst$CHR)
fst$CHR<-gsub(pattern = "scaffold_",replacement = "",x = fst$CHR)
fst$CHR <- as.numeric(fst$CHR)

manhattan(fst, chr="CHR", bp="BP", snp="ID", p="V6", suggestiveline = F, 
          genomewideline = F, logp = F, ylim =c(0,1)) #p here refers to pvalue or in this case the Fst value, substitute with which column comparison you are interested in graphing



#####POOLFSTAT################
#Set pool sizes vector and poolsizes (x2) for baypass for all 15 pops
poolsizes = c(42,48,48,48,31,31,37,24,47,47,28,32,48,42,39)
poolsizesbaypass=poolsizes*2
poolnames = c("NS_B", "NS_E","NS_C","QCNS","BBN","CAR","LAB8A","LAB10B","LAB4","LAB5A","LAB2N","CBT","LAB3B","LAB6B","LAB3N200")

#Let's read in our sync file generated by popoolation2 for all pops
#the sync file is 1561.135 million lines; 2,652,638 were found which took 217 minutes (min.rc=2)

crabpools<-popsync2pooldata(sync.file = "Grenedalf_Analyses/SnowCrab30counts.sync",
                                  poolsizes = poolsizes,
                                  poolnames = poolnames,
                                  min.rc = 3,
                                  min.cov.per.pool = 30,
                                  max.cov.per.pool = 400,
                                  min.maf = 0.05,
                                  noindel = TRUE, 
                                  nlines.per.readblock = 1e+06,
                                  nthreads = 60)



#Do pairwise Fst for all pops
crabpairFST.maf05 <- compute.pairwiseFST(crabpools, method = "Anova",
                                          min.cov.per.pool = 30, max.cov.per.pool = 500,
                                          min.maf = 0.05,
                                          output.snp.values = FALSE,
                                          verbose=TRUE)
write.csv(zos.pair.fst.noTSW@PairwiseFSTmatrix,file="PairwiseFST.NoTSW.csv", quote=F)

#Can subset pooldata if need be
#zospools.subset <- pooldata.subset(pooldata = zospools, min.maf = 0.05,verbose = TRUE) #this doesn't do anything since we filtered by a maf of 0.05 above
# #Results:
# 258.6106 millions lines processed in 49.54  min.;  516094 SNPs found
# Data consists of 516094 SNPs for 23 Pools

##### From this file we can compute global and per SNP FSTs
#use a sliding window approach first
crab.snp.fsts <- computeFST(x=crabpools,method = "Anova",sliding.window.size = 10000)
plot(zos.snp.fsts$sliding.windows.fst$CumulatedPosition/1e4,zos.snp.fsts$sliding.windows.fst$MultiLocusFst,
     xlab="Cumulative Position (Mb)",ylab="Multi-locus Fst")
#col=zos.snp.fsts$sliding.windows.fst$Chr,pch=16)

#make this data usable for a manhattan plot

colnames(globalfsts) <-c("CHR", "BP", "SNP","FST") #rename column headers
globalfsts$CHR <-gsub("Chr","",globalfsts$CHR)
globalfsts$CHR <-gsub("scaffold_","",globalfsts$CHR)
globalfsts$CHR <-as.numeric(globalfsts$CHR)

qqman::manhattan(globalfsts, chr="CHR", bp="BP", snp="SNP", p="FST", suggestiveline = F, 
                 genomewideline = F, logp = F, ylim =c(0,1),
                 annotatePval = 0.5, annotateTop = F) #p here refers to pvalue or in this case the Fst value, substitute with which column comparison you are interested in graphing


#now do some jackknifing to calculate standard error
zos.snp.fsts.jacked<-computeFST(zospools,method = "Anova",nsnp.per.bjack.block = 1000)

##### And we can compute pairwise FSTs among populations
zos.pair.fst <- compute.pairwiseFST(zospools, method = "Anova",
                                    min.cov.per.pool = 20, max.cov.per.pool = 500,
                                    min.maf = 0.01,
                                    output.snp.values = FALSE,
                                    verbose=TRUE)

##### Save the pairwise Fst matrix:
pairwisepools.fst <- zos.pair.fst@PairwiseFSTmatrix
write.csv(pairwisepools.fst,"Zostera_PairwisePoolsFST.csv")

#Do a quick plot to see how it looks
poolfstat::heatmap(pairwisepools.fst)
gplots::heatmap.2(pairwisepools.fst,dendrogram = "col",na.rm = T,trace = "none",density.info = "none",key.title = NA,key.xlab = "Pairwise Fst",symkey = F)
#Now compute fstats

zos.fstats<-compute.fstats(x = zospools,nsnp.per.bjack.block = 1000,computeDstat = T,verbose = T)

#try to build an NJ tree
scaf.pops <-find.tree.popset(zos.fstats,verbose = T)
scaf.tree <- rooted.njtree.builder(fstats = zos.fstats,pop.sel = scaf.pops$pop.sets[1,],plot.nj = T,verbose = T)

#This tree apparently has negative branch lengths, probably because Pool 23 is so different. So the relationships make sense, but it's not the best tree

##################################################################################
###### Next, we will convert the poolfstat file to BayPass input files############
##################################################################################

#### Here you get three output files = genobaypass (allele counts), poolsize (haploid size per pool), & snpdet (snp info matrix). These will automatically be written in your working directory. Note the subsample size here can be used to sample to a smaller number of SNPs. If the subsample size is <0, then all SNPs are included in the BayPass files.
pooldata2genobaypass(zospools, writing.dir = getwd(), subsamplesize = -1)

#Let's also make a randomly subset BayPass file
pooldata2genobaypass(zospools, writing.dir = getwd(), subsamplesize = 50000, subsamplingmethod = "random", prefix = "ZosBayPassSUBSET")

#Let's also create a countdata object using the genobaypass file
#ZM.countdata <- genobaypass2countdata(genobaypass.file = "ZosteraAllPools.genobaypass",popnames = poolnames,min.maf = 0.05,verbose = T)

################################# LD PRUNING ###############################

# To run the script below, you need to take the snpdet output from the poolfstat2baypass command above, and give the columns headers. Importantly, the first column must be titled "scaffold" and the second column must be titled "pos" (these are the contig and position columns).Here I called this file 'snpdet.pruning.txt'

# Read input file
data<-read.table("snpdet",header=F)

# Initiate data for LD pruning
data_LD<-NULL

# Window for LD pruning, here at 1000 bp (select 1 SNP per 1000 base pairs)
window<-1000

# Print every unique contig, and for every contig, randomly subsample 1 SNP per 1000 bp window - this is not that useful to me since I have chromosome data, not contig data, so there will be few snps picked out based on chromsome names
# scaffold_ID<-unique(data$scaffold)
# for(i in 1:length(scaffold_ID)){
#   print(scaffold_ID[i])
#   subset<-data[which(data$scaffold==scaffold_ID[i]),]
#   for(j in 0:10){
#     print(window*j+1)
#     subset_bin_i<-subset[which(subset$pos>=window*j & subset$pos<=window*(j+1)),]
#     random<-sample(1:length(subset_bin_i[,1]),1)
#     subsubset<-subset_bin_i[random,]
#     data_LD<-rbind(data_LD,subsubset)
#   }
# }

# Get the unique LD pruned SNP list
uniq.LD <- unique(data_LD)

# Write to excel file
WriteXLS(uniq.LD, "ZosteraAllPools.LD.list.xls")

####### SUBSET BAYPASS FILE  ###########

# Here we are going to filter our BayPass input files to now only relate to the LD-pruned SNPs. To do this, we first need to combine the .genobaypass and .snpdet output files from above. So in excel or text editor, have the first columns relate to the .snpdet output, then add the .genobaypass columns following. In other words, your input file here is the contig position, allele states, and then allele counts. Make sure the columns do not have headers. Here I called this file 'SG.snpdet.geno.txt'

library(dplyr)

# Read the .genobaypass/.snpdet file type explained above, relating to all SNPs
snp.data<-read.table("ZosteraAllPools.genobaypass",sep="",header=F)

# Read your LD SNP list. To make this text file, I just took the first two columns of the SG.LD.list excel file just created, and turned that into a text file. So basically a text file with first column being contig, and second column being position for all LD-pruned SNPs (but with no column headers)
ld.data<-read.table("ZosteraAllPools.LD.list.xls",sep="\t",header=F)

# Filter the list of all SNPs to now only list the LD pruned SNPs
snp.data.f <- dplyr::inner_join(snp.data, ld.data)

# Write out as new file, and then from there you can split back up into new .snpdet and .genobaypass input files


################################# BAYPASS CREATE OMEGA ###############################
##################################################################################

source("/home/mcrg/baypass_2.3/utils/baypass_utils.R")


# Read omega matrix BayPass output 
SG.omega=as.matrix(read.table("ZosBayPass_mat_omega.out"))

# Identify pool names for plotting
colnames(SG.omega) <- c("MASI","SAC","L3F","SUM","POK","PRJ","SAM","MASS","RIM",
                        "SEPT","GRB","HEB","PORT", "PETI","NRIV","EBAY","POUL","JB33","JB38","BUCK","MELM","TAYH","TSW")
rownames(SG.omega) <- c("MASI","SAC","L3F","SUM","POK","PRJ","SAM","MASS","RIM",
                        "SEPT","GRB","HEB","PORT", "PETI","NRIV","EBAY","POUL","JB33","JB38","BUCK","MELM","TAYH","TSW")
pops=c("MASI","SAC","L3F","SUM","POK","PRJ","SAM","MASS","RIM",
       "SEPT","GRB","HEB","PORT", "PETI","NRIV","EBAY","POUL","JB33","JB38","BUCK","MELM","TAYH","TSW")
# Create a correlation matrix of the omega values, which can be used to assess genomic differentiation between pools
cor.mat=cov2cor(SG.omega)
corrplot(cor.mat,method="color",mar=c(2,1,2,2)+0.1,
         main=expression("Correlation map based on"~hat(Omega)))

# We can also assess population differentiation with hierarchical clustering:
ZosBayPass.tree=as.phylo(hclust(as.dist(1-cor.mat**2)))
#use plot.phylo and its details to make a nice looking tree
plot(ZosBayPass.tree,type="fan",
     edge.width=3,
     font=2,
     lab4ut="axial",
     label.offset=0.01,
     main=expression("Hier. clust. tree based on"~hat(Omega)~"("*d[ij]*"=1-"*rho[ij]*")"))

#This clustering tree makes more sense than our previous NJ tree and shows some interesting results!

#Now plot the omega matrix
plot.omega(omega = SG.omega,pop.names = pops,PC = c(1,2))
#Try another PC axis as this one just shows an Atlantic-Pacific divide
plot.omega(omega = SG.omega,pop.names = pops,PC = c(2,3))
#this still shows an Atlantic-Pacific divide but also shows a north-south divide along PC3
plot.omega(omega = SG.omega,pop.names = pops,PC = c(1,3))
#and this plot shows TSW off by itself, and JB38&33 off by themselves, while Atlantic Canada clusters in the middle

####Outlier detection###############
#Now detect outliers based on the real data and simulated data using R functions and BayPass again
# Read the xtx BayPass output
ZM.snp.res=read.table("ZosBayPass_summary_pi_xtx.out",h=T)

# Get the Pi Beta distribution for POD generation (pseudo-observed data set)
ZM.pi.beta.coef=read.table("ZosBayPass_summary_beta_params.out",h=T)$Mean
#0.247412 0.306792

# Upload original data to get read counts
ZM.data<-geno2YN("ZosteraAllPools.genobaypass")

# Simulate POD dataset to use for outlier SNP detection
simu.ZM <-simulate.baypass(omega.mat=SG.omega,nsnp=20000,sample.size=ZM.data$NN,
                           beta.pi=ZM.pi.beta.coef,pi.maf=0,suffix="ZM.BP.sim")


################################# BAYPASS GET OUTLIERS ###############################
##################################################################################

source("baypass_utils.R")


# Read the new omega matrix and compare to original. Here you want similar values between the two
SG.pod.omega=as.matrix(read.table("ZM.BP.sim_mat_omega.out"))
plot(SG.pod.omega,SG.omega) ; abline(a=0,b=1)

# Get the Forstner and Moonen Distance (FMD) between simulated and original posterior estimates (here a smaller value is better) 
fmd.dist(SG.pod.omega,SG.omega)

# Look at POD xtx values, and identify SNPs where the xtx values are above the 99% significance threshold from the POD. So in the plot, it is those loci (dots) which are above the abline
SG.pod.xtx=read.table("ZM.BP.sim_summary_pi_xtx.out",h=T)$M_XtX
SG.pod.thresh=quantile(SG.pod.xtx,probs=0.99)
plot(ZM.snp.res$M_XtX)
abline(h=SG.pod.thresh,lty=2)


SG.pod.thresh
#33.16624

# Here I just saved the xtx values per SNP list, and then in excel/text editor filtered out the SNPs with an xtx greater than the threshold value as outliers.
SG.snp.scores <- as.data.frame(ZM.snp.res$M_XtX)
write.table(SG.snp.scores, file="SG.snp.scores.txt", sep="\t")





###################################################################################################
###########################NUCLEOTIDE DIVERSITY PLOTS AND STATS####################################
###################################################################################################
list.files()
setwd("PopoolationResults/")
#import each pi file and do some cleanup:
pi_1 <- read.delim("Pool1.pi", header = F)
colnames(pi_1) <- c("Chromosome", "window", "num.snps", "frac", "pi_1")
pi_1$ID <- paste(pi_1$Chromosome, pi_1$window, sep = '_')
pi_1 <- pi_1[!pi_1$pi_1 == "na",] #remove rows with na
pi_1 <- pi_1[,c(6,5)]

pi_2 <- read.delim("Pool2.pi", header = F)
colnames(pi_2) <- c("Chromosome", "window", "num.snps", "frac", "pi_2")
pi_2$ID <- paste(pi_2$Chromosome, pi_2$window, sep = '_')
pi_2 <- pi_2[!pi_2$pi_2 == "na",]
pi_2 <- pi_2[,c(6,5)]

pi_3 <- read.delim("Pool3.pi", header = F)
colnames(pi_3) <- c("Chromosome", "window", "num.snps", "frac", "pi_3")
pi_3$ID <- paste(pi_3$Chromosome, pi_3$window, sep = '_')
pi_3 <- pi_3[!pi_3$pi_3 == "na",] #remove rows with na
pi_3 <- pi_3[,c(6,5)]

pi_4 <- read.delim("Pool4.pi", header = F)
colnames(pi_4) <- c("Chromosome", "window", "num.snps", "frac", "pi_4")
pi_4$ID <- paste(pi_4$Chromosome, pi_4$window, sep = '_')
pi_4 <- pi_4[!pi_4$pi_4 == "na",]
pi_4 <- pi_4[,c(6,5)]

pi_5 <- read.delim("Pool5.pi", header = F)
colnames(pi_5) <- c("Chromosome", "window", "num.snps", "frac", "pi_5")
pi_5$ID <- paste(pi_5$Chromosome, pi_5$window, sep = '_')
pi_5 <- pi_5[!pi_5$pi_5 == "na",] #remove rows with na
pi_5 <- pi_5[,c(6,5)]

pi_6 <- read.delim("Pool6.pi", header = F)
colnames(pi_6) <- c("Chromosome", "window", "num.snps", "frac", "pi_6")
pi_6$ID <- paste(pi_6$Chromosome, pi_6$window, sep = '_')
pi_6 <- pi_6[!pi_6$pi_6 == "na",] #remove rows with na
pi_6 <- pi_6[,c(6,5)]

pi_7 <- read.delim("Pool7.pi", header = F)
colnames(pi_7) <- c("Chromosome", "window", "num.snps", "frac", "pi_7")
pi_7$ID <- paste(pi_7$Chromosome, pi_7$window, sep = '_')
pi_7 <- pi_7[!pi_7$pi_7 == "na",]
pi_7 <- pi_7[,c(6,5)]

pi_8 <- read.delim("Pool8.pi", header = F)
colnames(pi_8) <- c("Chromosome", "window", "num.snps", "frac", "pi_8")
pi_8$ID <- paste(pi_8$Chromosome, pi_8$window, sep = '_')
pi_8 <- pi_8[!pi_8$pi_8 == "na",] #remove rows with na
pi_8 <- pi_8[,c(6,5)]

pi_9 <- read.delim("Pool9.pi", header = F)
colnames(pi_9) <- c("Chromosome", "window", "num.snps", "frac", "pi_9")
pi_9$ID <- paste(pi_9$Chromosome, pi_9$window, sep = '_')
pi_9 <- pi_9[!pi_9$pi_9 == "na",]
pi_9 <- pi_9[,c(6,5)]

pi_10 <- read.delim("Pool10.pi", header = F)
colnames(pi_10) <- c("Chromosome", "window", "num.snps", "frac", "pi_10")
pi_10$ID <- paste(pi_10$Chromosome, pi_10$window, sep = '_')
pi_10 <- pi_10[!pi_10$pi_10 == "na",]
pi_10 <- pi_10[,c(6,5)]

pi_11 <- read.delim("Pool11.pi", header = F)
colnames(pi_11) <- c("Chromosome", "window", "num.snps", "frac", "pi_11")
pi_11$ID <- paste(pi_11$Chromosome, pi_11$window, sep = '_')
pi_11 <- pi_11[!pi_11$pi_11 == "na",]
pi_11 <- pi_11[,c(6,5)]

pi_12 <- read.delim("Pool12.pi", header = F)
colnames(pi_12) <- c("Chromosome", "window", "num.snps", "frac", "pi_12")
pi_12$ID <- paste(pi_12$Chromosome, pi_12$window, sep = '_')
pi_12 <- pi_12[!pi_12$pi_12 == "na",]
pi_12 <- pi_12[,c(6,5)]

pi_13 <- read.delim("Pool13.pi", header = F)
colnames(pi_13) <- c("Chromosome", "window", "num.snps", "frac", "pi_13")
pi_13$ID <- paste(pi_13$Chromosome, pi_13$window, sep = '_')
pi_13 <- pi_13[!pi_13$pi_13 == "na",]
pi_13 <- pi_13[,c(6,5)]

pi_14 <- read.delim("Pool14.pi", header = F)
colnames(pi_14) <- c("Chromosome", "window", "num.snps", "frac", "pi_14")
pi_14$ID <- paste(pi_14$Chromosome, pi_14$window, sep = '_')
pi_14 <- pi_14[!pi_14$pi_14 == "na",]
pi_14 <- pi_14[,c(6,5)]

pi_15 <- read.delim("Pool15.pi", header = F)
colnames(pi_15) <- c("Chromosome", "window", "num.snps", "frac", "pi_15")
pi_15$ID <- paste(pi_15$Chromosome, pi_15$window, sep = '_')
pi_15 <- pi_15[!pi_15$pi_15 == "na",]
pi_15 <- pi_15[,c(6,5)]

pi_16 <- read.delim("Pool16.pi", header = F)
colnames(pi_16) <- c("Chromosome", "window", "num.snps", "frac", "pi_16")
pi_16$ID <- paste(pi_16$Chromosome, pi_16$window, sep = '_')
pi_16 <- pi_16[!pi_16$pi_16 == "na",]
pi_16 <- pi_16[,c(6,5)]

pi_17 <- read.delim("Pool17.pi", header = F)
colnames(pi_17) <- c("Chromosome", "window", "num.snps", "frac", "pi_17")
pi_17$ID <- paste(pi_17$Chromosome, pi_17$window, sep = '_')
pi_17 <- pi_17[!pi_17$pi_17 == "na",]
pi_17 <- pi_17[,c(6,5)]

pi_18 <- read.delim("Pool18.pi", header = F)
colnames(pi_18) <- c("Chromosome", "window", "num.snps", "frac", "pi_18")
pi_18$ID <- paste(pi_18$Chromosome, pi_18$window, sep = '_')
pi_18 <- pi_18[!pi_18$pi_18 == "na",]
pi_18 <- pi_18[,c(6,5)]

pi_19 <- read.delim("Pool19.pi", header = F)
colnames(pi_19) <- c("Chromosome", "window", "num.snps", "frac", "pi_19")
pi_19$ID <- paste(pi_19$Chromosome, pi_19$window, sep = '_')
pi_19 <- pi_19[!pi_19$pi_19 == "na",]
pi_19 <- pi_19[,c(6,5)]

pi_20 <- read.delim("Pool20.pi", header = F)
colnames(pi_20) <- c("Chromosome", "window", "num.snps", "frac", "pi_20")
pi_20$ID <- paste(pi_20$Chromosome, pi_20$window, sep = '_')
pi_20 <- pi_20[!pi_20$pi_20 == "na",]
pi_20 <- pi_20[,c(6,5)]

pi_21 <- read.delim("Pool21.pi", header = F)
colnames(pi_21) <- c("Chromosome", "window", "num.snps", "frac", "pi_21")
pi_21$ID <- paste(pi_21$Chromosome, pi_21$window, sep = '_')
pi_21 <- pi_21[!pi_21$pi_21 == "na",]
pi_21 <- pi_21[,c(6,5)]

pi_22 <- read.delim("Pool22.pi", header = F)
colnames(pi_22) <- c("Chromosome", "window", "num.snps", "frac", "pi_22")
pi_22$ID <- paste(pi_22$Chromosome, pi_22$window, sep = '_')
pi_22 <- pi_22[!pi_22$pi_22 == "na",]
pi_22 <- pi_22[,c(6,5)]

pi_23 <- read.delim("Pool23.pi", header = F)
colnames(pi_23) <- c("Chromosome", "window", "num.snps", "frac", "pi_23")
pi_23$ID <- paste(pi_23$Chromosome, pi_23$window, sep = '_')
pi_23 <- pi_23[!pi_23$pi_23 == "na",]
pi_23 <- pi_23[,c(6,5)]




#merge all pi results into one file
pi_all1 <- merge(pi_1, pi_2, by="ID")
pi_all2 <- merge(pi_all1, pi_3, by="ID")
pi_all3 <- merge(pi_all2, pi_4, by="ID")
pi_all4 <- merge(pi_all3, pi_5, by="ID")
pi_all5 <- merge(pi_all4, pi_6, by="ID")
pi_all6 <- merge(pi_all5, pi_7, by="ID")
pi_all7 <- merge(pi_all6, pi_8, by="ID")
pi_all8 <- merge(pi_all7, pi_9, by="ID")
pi_all9 <- merge(pi_all8, pi_10, by="ID")
pi_all10 <- merge(pi_all9, pi_11, by="ID")
pi_all11 <- merge(pi_all10, pi_12, by="ID")
pi_all12 <- merge(pi_all11, pi_13, by="ID")
pi_all13 <- merge(pi_all12, pi_14, by="ID")
pi_all14 <- merge(pi_all13, pi_15, by="ID")
pi_all15 <- merge(pi_all14, pi_16, by="ID")
pi_all16 <- merge(pi_all15, pi_17, by="ID")
pi_all17 <- merge(pi_all16, pi_18, by="ID")
pi_all18 <- merge(pi_all17, pi_19, by="ID")
pi_all19 <- merge(pi_all18, pi_20, by="ID")
pi_all20 <- merge(pi_all19, pi_21, by="ID")
pi_all21 <- merge(pi_all20, pi_22, by="ID")
pi_all <- merge(pi_all21, pi_23, by="ID")


pi_all$pi_1 <- as.numeric(pi_all$pi_1)
pi_all$pi_2 <- as.numeric(pi_all$pi_2)
pi_all$pi_3 <- as.numeric(pi_all$pi_3)
pi_all$pi_4 <- as.numeric(pi_all$pi_4)
pi_all$pi_5 <- as.numeric(pi_all$pi_5)
pi_all$pi_6 <- as.numeric(pi_all$pi_6)
pi_all$pi_7 <- as.numeric(pi_all$pi_7)
pi_all$pi_8 <- as.numeric(pi_all$pi_8)
pi_all$pi_9 <- as.numeric(pi_all$pi_9)
pi_all$pi_10 <- as.numeric(pi_all$pi_10)
pi_all$pi_12 <- as.numeric(pi_all$pi_12)
pi_all$pi_11 <- as.numeric(pi_all$pi_11)
pi_all$pi_13 <- as.numeric(pi_all$pi_13)
pi_all$pi_14 <- as.numeric(pi_all$pi_14)
pi_all$pi_15 <- as.numeric(pi_all$pi_15)
pi_all$pi_16 <- as.numeric(pi_all$pi_16)
pi_all$pi_17 <- as.numeric(pi_all$pi_17)
pi_all$pi_18 <- as.numeric(pi_all$pi_18)
pi_all$pi_19 <- as.numeric(pi_all$pi_19)
pi_all$pi_20 <- as.numeric(pi_all$pi_20)
pi_all$pi_21 <- as.numeric(pi_all$pi_21)
pi_all$pi_22 <- as.numeric(pi_all$pi_22)
pi_all$pi_23 <- as.numeric(pi_all$pi_23)

#get the mean pi value per pool
my_list<-list()
#remove first column
pi_allNEW<-pi_all[,-1]
for(i in 1:ncol(pi_allNEW)){
  output<-mean(x=pi_allNEW[, i])
  my_list[i]<-output
}
my_list

dds.pcoa=pcoa(vegdist((pi_all[,2:24]), method="euclidean")/1000)
scores=dds.pcoa$vectors
percent <- dds.pcoa$values$Eigenvalues
percent / sum(percent) #percent for each axes; change in caption below

windows()
plot(scores[,1], scores[,2],
     col=c(rep("red", 22),"blue"),
     pch = c(19,19,19,19,19,19,19,19,19,19,1,19),
     xlab = "PC1 (24.33%)", ylab = "PC2 (21.24%)")

treat_df <- data.frame(
  ID = c("MASI","SAC","L3F","SUM","POK","PRJ","SAM","MASS","RIM",
         "SEPT","GRB","HEB","PORT", "PETI","NRIV","EBAY","POUL","JB33","JB38","BUCK","MELM","TAYH","TSW"),
  line = c("A", "A", "A", "G", "G", "A", "A", "A", "G",
           "G","A","A","A","G","G","A","G","J","J","G","G","A","P")
)

line <- treat_df$line
library(vegan)
adonis2(t(pi_all[,2:24])~line, data = treat_df, permutations = 1000000, method = "manhattan")

###Adonis output
# Permutation test for adonis under reduced model
# Terms added sequentially (first to last)
# Permutation: free
# Number of permutations: 1e+06
# 
# adonis2(formula = t(pi_all[, 2:24]) ~ line, data = treat_df, permutations = 1e+06, method = "manhattan")
# Df SumOfSqs      R2      F Pr(>F)    
# line      3   5348.4 0.96683 184.62  1e-06 ***
#   Residual 19    183.5 0.03317                  
# Total    22   5531.9 1.00000                  
# ---
#   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1



########################################
#######TAJIMA'S D#######################

#import each Taj D file and do some cleanup:
D_1 <- read.delim("Pool1.D", header = F)
colnames(D_1) <- c("Chromosome", "window", "num.snps", "frac", "D_1")
D_1$ID <- paste(D_1$Chromosome, D_1$window, sep = '_')
D_1 <- D_1[!D_1$D_1 == "na",] #remove rows with na
D_1 <- D_1[,c(6,5)]

D_2 <- read.delim("Pool2.D", header = F)
colnames(D_2) <- c("Chromosome", "window", "num.snps", "frac", "D_2")
D_2$ID <- paste(D_2$Chromosome, D_2$window, sep = '_')
D_2 <- D_2[!D_2$D_2 == "na",]
D_2 <- D_2[,c(6,5)]

D_3 <- read.delim("Pool3.D", header = F)
colnames(D_3) <- c("Chromosome", "window", "num.snps", "frac", "D_3")
D_3$ID <- paste(D_3$Chromosome, D_3$window, sep = '_')
D_3 <- D_3[!D_3$D_3 == "na",] #remove rows with na
D_3 <- D_3[,c(6,5)]

D_4 <- read.delim("Pool4.D", header = F)
colnames(D_4) <- c("Chromosome", "window", "num.snps", "frac", "D_4")
D_4$ID <- paste(D_4$Chromosome, D_4$window, sep = '_')
D_4 <- D_4[!D_4$D_4 == "na",]
D_4 <- D_4[,c(6,5)]

D_5 <- read.delim("Pool5.D", header = F)
colnames(D_5) <- c("Chromosome", "window", "num.snps", "frac", "D_5")
D_5$ID <- paste(D_5$Chromosome, D_5$window, sep = '_')
D_5 <- D_5[!D_5$D_5 == "na",] #remove rows with na
D_5 <- D_5[,c(6,5)]

D_6 <- read.delim("Pool6.D", header = F)
colnames(D_6) <- c("Chromosome", "window", "num.snps", "frac", "D_6")
D_6$ID <- paste(D_6$Chromosome, D_6$window, sep = '_')
D_6 <- D_6[!D_6$D_6 == "na",] #remove rows with na
D_6 <- D_6[,c(6,5)]

D_7 <- read.delim("Pool7.D", header = F)
colnames(D_7) <- c("Chromosome", "window", "num.snps", "frac", "D_7")
D_7$ID <- paste(D_7$Chromosome, D_7$window, sep = '_')
D_7 <- D_7[!D_7$D_7 == "na",]
D_7 <- D_7[,c(6,5)]

D_8 <- read.delim("Pool8.D", header = F)
colnames(D_8) <- c("Chromosome", "window", "num.snps", "frac", "D_8")
D_8$ID <- paste(D_8$Chromosome, D_8$window, sep = '_')
D_8 <- D_8[!D_8$D_8 == "na",] #remove rows with na
D_8 <- D_8[,c(6,5)]

D_9 <- read.delim("Pool9.D", header = F)
colnames(D_9) <- c("Chromosome", "window", "num.snps", "frac", "D_9")
D_9$ID <- paste(D_9$Chromosome, D_9$window, sep = '_')
D_9 <- D_9[!D_9$D_9 == "na",]
D_9 <- D_9[,c(6,5)]

D_10 <- read.delim("Pool10.D", header = F)
colnames(D_10) <- c("Chromosome", "window", "num.snps", "frac", "D_10")
D_10$ID <- paste(D_10$Chromosome, D_10$window, sep = '_')
D_10 <- D_10[!D_10$D_10 == "na",]
D_10 <- D_10[,c(6,5)]

D_11 <- read.delim("Pool11.D", header = F)
colnames(D_11) <- c("Chromosome", "window", "num.snps", "frac", "D_11")
D_11$ID <- paste(D_11$Chromosome, D_11$window, sep = '_')
D_11 <- D_11[!D_11$D_11 == "na",]
D_11 <- D_11[,c(6,5)]

D_12 <- read.delim("Pool12.D", header = F)
colnames(D_12) <- c("Chromosome", "window", "num.snps", "frac", "D_12")
D_12$ID <- paste(D_12$Chromosome, D_12$window, sep = '_')
D_12 <- D_12[!D_12$D_12 == "na",]
D_12 <- D_12[,c(6,5)]

D_13 <- read.delim("Pool13.D", header = F)
colnames(D_13) <- c("Chromosome", "window", "num.snps", "frac", "D_13")
D_13$ID <- paste(D_13$Chromosome, D_13$window, sep = '_')
D_13 <- D_13[!D_13$D_13 == "na",]
D_13 <- D_13[,c(6,5)]

D_14 <- read.delim("Pool14.D", header = F)
colnames(D_14) <- c("Chromosome", "window", "num.snps", "frac", "D_14")
D_14$ID <- paste(D_14$Chromosome, D_14$window, sep = '_')
D_14 <- D_14[!D_14$D_14 == "na",]
D_14 <- D_14[,c(6,5)]

D_15 <- read.delim("Pool15.D", header = F)
colnames(D_15) <- c("Chromosome", "window", "num.snps", "frac", "D_15")
D_15$ID <- paste(D_15$Chromosome, D_15$window, sep = '_')
D_15 <- D_15[!D_15$D_15 == "na",]
D_15 <- D_15[,c(6,5)]

D_16 <- read.delim("Pool16.D", header = F)
colnames(D_16) <- c("Chromosome", "window", "num.snps", "frac", "D_16")
D_16$ID <- paste(D_16$Chromosome, D_16$window, sep = '_')
D_16 <- D_16[!D_16$D_16 == "na",]
D_16 <- D_16[,c(6,5)]

D_17 <- read.delim("Pool17.D", header = F)
colnames(D_17) <- c("Chromosome", "window", "num.snps", "frac", "D_17")
D_17$ID <- paste(D_17$Chromosome, D_17$window, sep = '_')
D_17 <- D_17[!D_17$D_17 == "na",]
D_17 <- D_17[,c(6,5)]

D_18 <- read.delim("Pool18.D", header = F)
colnames(D_18) <- c("Chromosome", "window", "num.snps", "frac", "D_18")
D_18$ID <- paste(D_18$Chromosome, D_18$window, sep = '_')
D_18 <- D_18[!D_18$D_18 == "na",]
D_18 <- D_18[,c(6,5)]

D_19 <- read.delim("Pool19.D", header = F)
colnames(D_19) <- c("Chromosome", "window", "num.snps", "frac", "D_19")
D_19$ID <- paste(D_19$Chromosome, D_19$window, sep = '_')
D_19 <- D_19[!D_19$D_19 == "na",]
D_19 <- D_19[,c(6,5)]

D_20 <- read.delim("Pool20.D", header = F)
colnames(D_20) <- c("Chromosome", "window", "num.snps", "frac", "D_20")
D_20$ID <- paste(D_20$Chromosome, D_20$window, sep = '_')
D_20 <- D_20[!D_20$D_20 == "na",]
D_20 <- D_20[,c(6,5)]

D_21 <- read.delim("Pool21.D", header = F)
colnames(D_21) <- c("Chromosome", "window", "num.snps", "frac", "D_21")
D_21$ID <- paste(D_21$Chromosome, D_21$window, sep = '_')
D_21 <- D_21[!D_21$D_21 == "na",]
D_21 <- D_21[,c(6,5)]

D_22 <- read.delim("Pool22.D", header = F)
colnames(D_22) <- c("Chromosome", "window", "num.snps", "frac", "D_22")
D_22$ID <- paste(D_22$Chromosome, D_22$window, sep = '_')
D_22 <- D_22[!D_22$D_22 == "na",]
D_22 <- D_22[,c(6,5)]

D_23 <- read.delim("Pool23.D", header = F)
colnames(D_23) <- c("Chromosome", "window", "num.snps", "frac", "D_23")
D_23$ID <- paste(D_23$Chromosome, D_23$window, sep = '_')
D_23 <- D_23[!D_23$D_23 == "na",]
D_23 <- D_23[,c(6,5)]




#merge all D results into one file
D_all1 <- merge(D_1, D_2, by="ID")
D_all2 <- merge(D_all1, D_3, by="ID")
D_all3 <- merge(D_all2, D_4, by="ID")
D_all4 <- merge(D_all3, D_5, by="ID")
D_all5 <- merge(D_all4, D_6, by="ID")
D_all6 <- merge(D_all5, D_7, by="ID")
D_all7 <- merge(D_all6, D_8, by="ID")
D_all8 <- merge(D_all7, D_9, by="ID")
D_all9 <- merge(D_all8, D_10, by="ID")
D_all10 <- merge(D_all9, D_11, by="ID")
D_all11 <- merge(D_all10, D_12, by="ID")
D_all12 <- merge(D_all11, D_13, by="ID")
D_all13 <- merge(D_all12, D_14, by="ID")
D_all14 <- merge(D_all13, D_15, by="ID")
D_all15 <- merge(D_all14, D_16, by="ID")
D_all16 <- merge(D_all15, D_17, by="ID")
D_all17 <- merge(D_all16, D_18, by="ID")
D_all18 <- merge(D_all17, D_19, by="ID")
D_all19 <- merge(D_all18, D_20, by="ID")
D_all20 <- merge(D_all19, D_21, by="ID")
D_all21 <- merge(D_all20, D_22, by="ID")
D_all <- merge(D_all21, D_23, by="ID")


D_all$D_1 <- as.numeric(D_all$D_1)
D_all$D_2 <- as.numeric(D_all$D_2)
D_all$D_3 <- as.numeric(D_all$D_3)
D_all$D_4 <- as.numeric(D_all$D_4)
D_all$D_5 <- as.numeric(D_all$D_5)
D_all$D_6 <- as.numeric(D_all$D_6)
D_all$D_7 <- as.numeric(D_all$D_7)
D_all$D_8 <- as.numeric(D_all$D_8)
D_all$D_9 <- as.numeric(D_all$D_9)
D_all$D_10 <- as.numeric(D_all$D_10)
D_all$D_12 <- as.numeric(D_all$D_12)
D_all$D_11 <- as.numeric(D_all$D_11)
D_all$D_13 <- as.numeric(D_all$D_13)
D_all$D_14 <- as.numeric(D_all$D_14)
D_all$D_15 <- as.numeric(D_all$D_15)
D_all$D_16 <- as.numeric(D_all$D_16)
D_all$D_17 <- as.numeric(D_all$D_17)
D_all$D_18 <- as.numeric(D_all$D_18)
D_all$D_19 <- as.numeric(D_all$D_19)
D_all$D_20 <- as.numeric(D_all$D_20)
D_all$D_21 <- as.numeric(D_all$D_21) 
D_all$D_22 <- as.numeric(D_all$D_22)
D_all$D_23 <- as.numeric(D_all$D_23)

#get the mean D value per pool
my_list<-list()
#remove first column
D_allNEW<-D_all[,-1]
for(i in 1:ncol(D_allNEW)){
  output<-mean(x=D_allNEW[, i])
  my_list[i]<-output
}
my_list

dds.pcoa=pcoa(vegdist(t(D_all[,2:24]), method="euclidean"))
scores=dds.pcoa$vectors
percent <- dds.pcoa$values$Eigenvalues
percent / sum(percent) #percent for each axes; change in caption below

windows()
plot(scores[,1], scores[,2],
     col=c(rep("red", 22),"blue"),
     pch = c(19,19,19,19,19,19,19,19,19,19,1,19),
     xlab = "PC1 (24.33%)", ylab = "PC2 (21.24%)")


#Save the data
save.image("SnowCrabPoolfstat.RData")

